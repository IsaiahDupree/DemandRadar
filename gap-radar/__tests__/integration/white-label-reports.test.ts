/**
 * Integration tests for white-label report generation
 * Tests the full flow: config → report API → PDF generation
 */

import { createClient } from '@supabase/supabase-js';

// Mock dependencies
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(),
}));

jest.mock('@/lib/subscription/permissions', () => ({
  getUserSubscription: jest.fn(),
}));

import { getUserSubscription } from '@/lib/subscription/permissions';
import {
  getWhiteLabelConfig,
  setWhiteLabelConfig,
  applyWhiteLabelToReport
} from '@/lib/reports/white-label';

describe('White-Label Report Integration', () => {
  let mockSupabase: any;

  beforeEach(() => {
    jest.clearAllMocks();

    // Setup mock Supabase client
    mockSupabase = {
      from: jest.fn(),
      auth: {
        getUser: jest.fn(),
      },
    };
  });

  describe('End-to-End White-Label Flow', () => {
    it('should apply custom branding to report for Studio users', async () => {
      // Mock Studio subscription
      (getUserSubscription as jest.Mock).mockResolvedValue({
        tier: 'studio',
        status: 'active',
      });

      // Mock successful config upsert
      const mockUpsert = jest.fn().mockResolvedValue({ error: null });
      mockSupabase.from.mockReturnValue({ upsert: mockUpsert });

      // Set custom branding
      const customBranding = {
        companyName: 'Acme Research',
        logoUrl: 'https://acme.com/logo.png',
        primaryColor: '#FF5733',
        secondaryColor: '#333333',
        removeBranding: true,
      };

      const setResult = await setWhiteLabelConfig(
        mockSupabase,
        'user-123',
        customBranding
      );

      expect(setResult.success).toBe(true);

      // Mock successful config retrieval
      const mockSelect = jest.fn();
      const mockEq = jest.fn();
      const mockSingle = jest.fn();

      mockSupabase.from.mockReturnValue({ select: mockSelect });
      mockSelect.mockReturnValue({ eq: mockEq });
      mockEq.mockReturnValue({ single: mockSingle });
      mockSingle.mockResolvedValue({
        data: {
          user_id: 'user-123',
          company_name: 'Acme Research',
          logo_url: 'https://acme.com/logo.png',
          primary_color: '#FF5733',
          secondary_color: '#333333',
          remove_branding: true,
        },
        error: null,
      });

      // Retrieve config
      const getResult = await getWhiteLabelConfig(mockSupabase, 'user-123');

      expect(getResult.success).toBe(true);
      expect(getResult.config).toEqual({
        companyName: 'Acme Research',
        logoUrl: 'https://acme.com/logo.png',
        primaryColor: '#FF5733',
        secondaryColor: '#333333',
        removeBranding: true,
      });

      // Apply branding to mock report data
      const mockReport = {
        run: { id: 'run-123', niche_query: 'AI Tools' },
        scores: { opportunity: 85, confidence: 0.8 },
        summary: { nicheName: 'AI Tools' },
        branding: {
          companyName: 'DemandRadar',
          logoUrl: '/demandradar-logo.png',
        },
        footer: 'Generated by DemandRadar',
      };

      const brandedReport = applyWhiteLabelToReport(mockReport, getResult.config);

      // Verify branding was applied
      expect(brandedReport.branding.companyName).toBe('Acme Research');
      expect(brandedReport.branding.logoUrl).toBe('https://acme.com/logo.png');
      expect(brandedReport.footer).not.toContain('DemandRadar');
    });

    it('should preserve default branding for non-Studio users', async () => {
      // Mock Agency subscription (not Studio)
      (getUserSubscription as jest.Mock).mockResolvedValue({
        tier: 'agency',
        status: 'active',
      });

      // Attempt to set custom branding
      const customBranding = {
        companyName: 'Acme Research',
        removeBranding: true,
      };

      const setResult = await setWhiteLabelConfig(
        mockSupabase,
        'user-456',
        customBranding
      );

      // Should be rejected
      expect(setResult.success).toBe(false);
      expect(setResult.error).toContain('Studio plan');

      // Mock no config exists
      const mockSelect = jest.fn();
      const mockEq = jest.fn();
      const mockSingle = jest.fn();

      mockSupabase.from.mockReturnValue({ select: mockSelect });
      mockSelect.mockReturnValue({ eq: mockEq });
      mockEq.mockReturnValue({ single: mockSingle });
      mockSingle.mockResolvedValue({ data: null, error: null });

      const getResult = await getWhiteLabelConfig(mockSupabase, 'user-456');

      expect(getResult.success).toBe(true);
      expect(getResult.config).toBeNull();

      // Apply to report - should use default branding
      const mockReport = {
        run: { id: 'run-456', niche_query: 'SaaS Tools' },
        summary: { nicheName: 'SaaS Tools' },
        footer: 'Generated by DemandRadar',
      };

      const brandedReport = applyWhiteLabelToReport(mockReport, null);

      // Should preserve original report (no white-label applied)
      expect(brandedReport).toEqual(mockReport);
      expect(brandedReport.footer).toContain('DemandRadar');
    });

    it('should handle partial branding updates', async () => {
      // Mock Studio subscription
      (getUserSubscription as jest.Mock).mockResolvedValue({
        tier: 'studio',
        status: 'active',
      });

      // Mock successful upsert
      const mockUpsert = jest.fn().mockResolvedValue({ error: null });
      mockSupabase.from.mockReturnValue({ upsert: mockUpsert });

      // Set only logo URL
      const partialBranding = {
        logoUrl: 'https://custom.com/new-logo.png',
      };

      const setResult = await setWhiteLabelConfig(
        mockSupabase,
        'user-789',
        partialBranding
      );

      expect(setResult.success).toBe(true);
      expect(mockUpsert).toHaveBeenCalledWith({
        user_id: 'user-789',
        logo_url: 'https://custom.com/new-logo.png',
      });
    });

    it('should remove branding completely when removeBranding is true', async () => {
      const whiteLabelConfig = {
        companyName: 'Stealth Startup',
        removeBranding: true,
      };

      const mockReport = {
        run: { id: 'run-999' },
        summary: { nicheName: 'Test' },
        branding: {
          companyName: 'DemandRadar',
        },
        footer: 'Powered by DemandRadar - Market Intelligence Platform',
        watermark: 'DemandRadar',
        header: 'DemandRadar Report',
      };

      const brandedReport = applyWhiteLabelToReport(mockReport, whiteLabelConfig);

      // Verify all DemandRadar branding is removed
      expect(brandedReport.branding.companyName).toBe('Stealth Startup');
      expect(brandedReport.footer).not.toContain('DemandRadar');
      expect(brandedReport.watermark).toBeUndefined();
      expect(brandedReport.header).not.toContain('DemandRadar');
      expect(brandedReport.header).toContain('Stealth Startup');
    });
  });

  describe('Error Handling', () => {
    it('should handle database errors gracefully during config fetch', async () => {
      const mockSelect = jest.fn();
      const mockEq = jest.fn();
      const mockSingle = jest.fn();

      mockSupabase.from.mockReturnValue({ select: mockSelect });
      mockSelect.mockReturnValue({ eq: mockEq });
      mockEq.mockReturnValue({ single: mockSingle });
      mockSingle.mockResolvedValue({
        data: null,
        error: { message: 'Connection failed' },
      });

      const getResult = await getWhiteLabelConfig(mockSupabase, 'user-error');

      expect(getResult.success).toBe(false);
      expect(getResult.error).toBe('Failed to retrieve white-label configuration');
    });

    it('should handle database errors during config save', async () => {
      (getUserSubscription as jest.Mock).mockResolvedValue({
        tier: 'studio',
        status: 'active',
      });

      const mockUpsert = jest.fn().mockResolvedValue({
        error: { message: 'Save failed' },
      });
      mockSupabase.from.mockReturnValue({ upsert: mockUpsert });

      const setResult = await setWhiteLabelConfig(
        mockSupabase,
        'user-error',
        { companyName: 'Test' }
      );

      expect(setResult.success).toBe(false);
      expect(setResult.error).toBe('Failed to save white-label configuration');
    });
  });

  describe('Branding Validation', () => {
    it('should handle missing branding object in report data', () => {
      const mockReport = {
        run: { id: 'run-123' },
        summary: { nicheName: 'Test' },
        // No branding object
      };

      const whiteLabelConfig = {
        companyName: 'Custom Corp',
        logoUrl: 'https://custom.com/logo.png',
      };

      const brandedReport = applyWhiteLabelToReport(mockReport, whiteLabelConfig);

      // Should create branding object
      expect(brandedReport.branding).toBeDefined();
      expect(brandedReport.branding.companyName).toBe('Custom Corp');
      expect(brandedReport.branding.logoUrl).toBe('https://custom.com/logo.png');
    });

    it('should not mutate original report data', () => {
      const mockReport = {
        run: { id: 'run-123' },
        branding: {
          companyName: 'DemandRadar',
        },
      };

      const originalBranding = mockReport.branding.companyName;

      const whiteLabelConfig = {
        companyName: 'New Company',
      };

      applyWhiteLabelToReport(mockReport, whiteLabelConfig);

      // Original should be unchanged
      expect(mockReport.branding.companyName).toBe(originalBranding);
    });
  });
});
